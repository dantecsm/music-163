三个模块
第一模块 data: 
{lists: [{id, songListName}], selectedSongListId}
第二模块 data: 
{formData: [song, cover, resume], status, songListId}
第三模块 data: 
{lists: [{id, song}], status, songListId}

没有七牛，纯粹 leanCloud 编程

eventHub
createSongList
selectSongList
-reloadSongList

reloadSongList
showListedSongs
showUnListedSongs

-showListedSongs
-showUnListedSongs


第一系统：
初始化会
  调用重载工具
on('reloadSongList')
  调用重载工具
点击新建会
  清除自己身上的 selectedSongListId
  清除自己身上的 active 类
  emit('createSongList')，通知第二系统清理表单
点击列表上的歌会
  赋值 selectedSongListId 并触发标签 active
  emit('selectSongList', selectedSongListId)，通知第二系统填充表单
重载工具
  从 leanCloud 请求数据填充 lists
  渲染模型到视图

第二系统：
初始化会
  赋值 status 为 creating
  渲染空模型到视图
on('createSongList')
  会更改 status 为 creating，更改表头为“创建歌单”
  会将 songListId 赋值为空
  清理表单
on('selectSongList', selectedSongListId)
  会更改 status 为 editing，更改表头为“编辑歌单”
  会将 songListId 赋值为 selectedSongListId
  从 leanCloud 查询 songListId 获取数据填充 formData
  渲染模型到视图
点击改会
  收集表单上的数据为 formData
  读取 status 为 editing 或 creating
  根据 status 命令模型命令 leanCloud 更新或创建歌单数据
  then 里 emit('reloadSongList')
点击删会
  根据自己的 songListId 命令模型命令 leanCloud 删除歌单
  then 里 emit('reloadSongList')
点击查己会
  根据自己的 songListId emit('showListedSongs', songListId)
点击查它会
  根据自己的 songListId emit('showUnListedSongs', songListId)

第三系统：
初始化会
  渲染空模型到视图
on('showListedSongs', songListId)
  修改 status 为 showListedSongs
  调用重载工具
on('showUnListedSongs', songListId)
  修改 status 为 showUnlistedSongs
  调用重载工具
点击图标会
  读取 status 与 songListId, 根据取值选择删除歌曲还是添加歌曲
    删除歌曲命令模型命令 leanCloud 为 songListId 删除歌曲
    添加歌曲命令模型命令 leanCloud 为 songListId 添加歌曲
  then 里调用重载工具
重载工具
  会读取 status 决定是包含还是不包含歌单
  会读取 songListId
  根据 status 和 songListId 查询歌曲填充到 lists
  模型渲染到视图




leanCloud 的一对多操作原理
在多的一方放一个指针属性, 指向少的一方
把既有对象添加到一个列表
var 列表 = AV.Object.createWithoutData('Province', 数据行id)
var 元素 = AV.Object.createWithoutData('City', 数据行id)
元素.set('xx属性', 列表)
元素.save()

